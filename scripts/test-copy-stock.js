#!/usr/bin/env node
/**
 * Script de test pour la copie automatique du stock
 * 
 * Usage: node scripts/test-copy-stock.js [options]
 * Options:
 *   --create-test-data : Cr√©er des donn√©es de test
 *   --test-copy : Tester la copie (dry-run)
 *   --test-real-copy : Tester la copie r√©elle
 *   --clean-test-data : Nettoyer les donn√©es de test
 */

const path = require('path');
const fs = require('fs').promises;
const { StockCopyProcessor, DateUtils, FileManager, Logger } = require('./copy-stock-cron');

const logger = new Logger('debug');

class TestDataCreator {
    constructor() {
        this.fileManager = new FileManager();
    }

    async createTestStockSoir(date) {
        const testData = {
            "Mbao-Boeuf": {
                "date": DateUtils.formatDate(date),
                "typeStock": "soir",
                "Point de Vente": "Mbao",
                "Produit": "Boeuf",
                "Nombre": "25.5",
                "PU": "3700",
                "Montant": "94350",
                "Commentaire": "Stock test automatique"
            },
            "O.Foire-Veau": {
                "date": DateUtils.formatDate(date),
                "typeStock": "soir",
                "Point de Vente": "O.Foire",
                "Produit": "Veau",
                "Nombre": "12.0",
                "PU": "3900",
                "Montant": "46800",
                "Commentaire": "Stock test veau"
            },
            "Linguere-Agneau": {
                "date": DateUtils.formatDate(date),
                "typeStock": "soir",
                "Point de Vente": "Linguere",
                "Produit": "Agneau",
                "Nombre": "8.75",
                "PU": "4500",
                "Montant": "39375",
                "Commentaire": "Stock test agneau"
            }
        };

        const stockSoirPath = this.fileManager.getStockSoirPath(date);
        await this.fileManager.writeJsonFile(stockSoirPath, testData);
        
        logger.info(`üìù Donn√©es de test cr√©√©es: ${stockSoirPath}`);
        return testData;
    }

    async cleanTestData(date) {
        const stockSoirPath = this.fileManager.getStockSoirPath(date);
        const stockMatinPath = this.fileManager.getStockMatinPath(DateUtils.addDays(date, 1));

        try {
            await fs.unlink(stockSoirPath);
            logger.info(`üóëÔ∏è Supprim√©: ${stockSoirPath}`);
        } catch (error) {
            if (error.code !== 'ENOENT') {
                logger.warn(`Erreur suppression ${stockSoirPath}:`, error.message);
            }
        }

        try {
            await fs.unlink(stockMatinPath);
            logger.info(`üóëÔ∏è Supprim√©: ${stockMatinPath}`);
        } catch (error) {
            if (error.code !== 'ENOENT') {
                logger.warn(`Erreur suppression ${stockMatinPath}:`, error.message);
            }
        }
    }
}

class TestRunner {
    constructor() {
        this.testDataCreator = new TestDataCreator();
        this.results = [];
    }

    async runTest(testName, testFunction) {
        logger.info(`\nüß™ Test: ${testName}`);
        try {
            const startTime = Date.now();
            const result = await testFunction();
            const duration = Date.now() - startTime;
            
            this.results.push({
                name: testName,
                success: true,
                duration,
                result
            });
            
            logger.info(`‚úÖ ${testName} - Succ√®s (${duration}ms)`);
            return result;
        } catch (error) {
            this.results.push({
                name: testName,
                success: false,
                error: error.message
            });
            
            logger.error(`‚ùå ${testName} - √âchec:`, error.message);
            throw error;
        }
    }

    async testCreateData() {
        return this.runTest('Cr√©ation de donn√©es de test', async () => {
            const testDate = DateUtils.getYesterday();
            const data = await this.testDataCreator.createTestStockSoir(testDate);
            
            if (!data || Object.keys(data).length === 0) {
                throw new Error('Aucune donn√©e cr√©√©e');
            }
            
            return { itemCount: Object.keys(data).length, date: DateUtils.formatDate(testDate) };
        });
    }

    async testDryRunCopy() {
        return this.runTest('Test copie (dry-run)', async () => {
            // Temporairement activer le dry-run
            const originalDryRun = process.argv.includes('--dry-run');
            if (!originalDryRun) {
                process.argv.push('--dry-run');
            }

            const processor = new StockCopyProcessor();
            const result = await processor.run();

            // Restaurer l'√©tat original
            if (!originalDryRun) {
                const index = process.argv.indexOf('--dry-run');
                if (index > -1) {
                    process.argv.splice(index, 1);
                }
            }

            if (!result.success) {
                throw new Error(result.error || 'Copie dry-run √©chou√©e');
            }

            return result;
        });
    }

    async testRealCopy() {
        return this.runTest('Test copie r√©elle', async () => {
            const processor = new StockCopyProcessor();
            const result = await processor.run();

            if (!result.success) {
                throw new Error(result.error || 'Copie r√©elle √©chou√©e');
            }

            return result;
        });
    }

    async testDataValidation() {
        return this.runTest('Validation des donn√©es copi√©es', async () => {
            const targetDate = DateUtils.getToday();
            const fileManager = new FileManager();
            const stockMatinPath = fileManager.getStockMatinPath(targetDate);

            const exists = await fileManager.fileExists(stockMatinPath);
            if (!exists) {
                throw new Error('Fichier stock matin non trouv√©');
            }

            const data = await fileManager.readJsonFile(stockMatinPath);
            if (!data || Object.keys(data).length === 0) {
                throw new Error('Donn√©es stock matin vides');
            }

            // V√©rifier la structure des donn√©es
            for (const [key, item] of Object.entries(data)) {
                if (!item.date || !item['Point de Vente'] || !item.Produit) {
                    throw new Error(`Structure invalide pour ${key}`);
                }

                if (item.typeStock !== 'matin') {
                    throw new Error(`Type stock incorrect pour ${key}: ${item.typeStock}`);
                }

                if (!item.Commentaire || !item.Commentaire.includes('Copi√© automatiquement')) {
                    throw new Error(`Commentaire de copie manquant pour ${key}`);
                }
            }

            return { 
                itemCount: Object.keys(data).length,
                sampleItem: Object.keys(data)[0],
                targetDate: DateUtils.formatDate(targetDate)
            };
        });
    }

    async testCleanup() {
        return this.runTest('Nettoyage des donn√©es de test', async () => {
            const testDate = DateUtils.getYesterday();
            await this.testDataCreator.cleanTestData(testDate);
            return { cleaned: true };
        });
    }

    async runAllTests() {
        logger.info('üöÄ D√©but des tests de copie automatique');
        
        try {
            // 1. Cr√©er des donn√©es de test
            await this.testCreateData();

            // 2. Tester en mode dry-run
            await this.testDryRunCopy();

            // 3. Tester la copie r√©elle
            await this.testRealCopy();

            // 4. Valider les donn√©es copi√©es
            await this.testDataValidation();

            // 5. Nettoyer
            await this.testCleanup();

            this.printSummary();
            return true;

        } catch (error) {
            logger.error('‚ùå Tests √©chou√©s:', error.message);
            this.printSummary();
            return false;
        }
    }

    printSummary() {
        logger.info('\nüìä R√©sum√© des tests:');
        logger.info('‚ïê'.repeat(50));

        let totalSuccess = 0;
        let totalTests = this.results.length;

        this.results.forEach(result => {
            const status = result.success ? '‚úÖ' : '‚ùå';
            const duration = result.duration ? ` (${result.duration}ms)` : '';
            logger.info(`${status} ${result.name}${duration}`);
            
            if (result.success) {
                totalSuccess++;
                if (result.result) {
                    logger.debug('  R√©sultat:', result.result);
                }
            } else {
                logger.error(`  Erreur: ${result.error}`);
            }
        });

        logger.info('‚ïê'.repeat(50));
        logger.info(`Total: ${totalSuccess}/${totalTests} tests r√©ussis`);
        
        if (totalSuccess === totalTests) {
            logger.info('üéâ Tous les tests sont pass√©s !');
        } else {
            logger.error('‚ùå Certains tests ont √©chou√©');
        }
    }
}

// Fonctions utilitaires pour les tests individuels
async function createTestData() {
    const creator = new TestDataCreator();
    const testDate = DateUtils.getYesterday();
    await creator.createTestStockSoir(testDate);
    logger.info('‚úÖ Donn√©es de test cr√©√©es');
}

async function testCopyDryRun() {
    process.argv.push('--dry-run');
    const processor = new StockCopyProcessor();
    const result = await processor.run();
    logger.info('‚úÖ Test dry-run termin√©:', result);
}

async function testRealCopy() {
    const processor = new StockCopyProcessor();
    const result = await processor.run();
    logger.info('‚úÖ Test copie r√©elle termin√©:', result);
}

async function cleanTestData() {
    const creator = new TestDataCreator();
    const testDate = DateUtils.getYesterday();
    await creator.cleanTestData(testDate);
    logger.info('‚úÖ Donn√©es de test nettoy√©es');
}

// Point d'entr√©e
async function main() {
    const args = process.argv.slice(2);
    
    if (args.includes('--create-test-data')) {
        await createTestData();
    } else if (args.includes('--test-copy')) {
        await testCopyDryRun();
    } else if (args.includes('--test-real-copy')) {
        await testRealCopy();
    } else if (args.includes('--clean-test-data')) {
        await cleanTestData();
    } else {
        // Ex√©cuter tous les tests
        const runner = new TestRunner();
        const success = await runner.runAllTests();
        process.exit(success ? 0 : 1);
    }
}

if (require.main === module) {
    main().catch(error => {
        logger.error('üí• Erreur fatale:', error.message);
        process.exit(1);
    });
}

module.exports = {
    TestDataCreator,
    TestRunner
};
